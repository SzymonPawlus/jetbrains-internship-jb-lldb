#include "elf.h"
#include "process.h"
#include <iostream>
#include <string>
#include <vector>

struct Options {
  std::string var;
  std::string exec_path;
  std::vector<std::string> exec_args;
};

// Generated by ChatGPT, I won't lie
Options parse_args(int argc, char *argv[]) {
  Options opts;
  bool after_double_dash = false;

  for (int i = 1; i < argc; ++i) {
    std::string arg = argv[i];

    if (after_double_dash) {
      // Everything after '--' goes to exec_args
      opts.exec_args.push_back(arg);
    } else if (arg == "--") {
      after_double_dash = true;
    } else if (arg == "--var") {
      if (i + 1 >= argc) {
        throw std::runtime_error("Missing argument for --var");
      }
      opts.var = argv[++i];
    } else if (arg == "--exec") {
      if (i + 1 >= argc) {
        throw std::runtime_error("Missing argument for --exec");
      }
      opts.exec_path = argv[++i];
    } else {
      throw std::runtime_error("Unknown argument: " + arg);
    }
  }

  if (opts.var.empty()) {
    throw std::runtime_error("--var argument is required");
  }
  if (opts.exec_path.empty()) {
    throw std::runtime_error("--exec argument is required");
  }

  return opts;
}

int main(int argc, char *argv[]) {
  try {
    Options options;
    options = parse_args(argc, argv);

    ELF elf;
    elf.load(options.exec_path);
    elf.validate();
    Process process(elf, std::move(options.exec_args));
    process.spawn();

    std::string symbol = options.var;

    process.set_watchpoint(symbol, false);
    long last_value = process.read_memory(symbol);

    process.continue_execution();
    while (process.wait()) {
      long value = process.read_memory(symbol);
      if (value ==
          last_value) { // Inaccurate in some cases, but doesn't waste
                        // additional debug registers which are scarce resource
        std::cout << symbol << " " << "read" << " " << value << std::endl;
      } else {
        std::cout << symbol << " " << "write" << " " << last_value << " -> "
                  << value << std::endl;
        last_value = value;
      }
      process.continue_execution();
    }
  } catch (const std::exception &e) {
    std::cerr << "Error: " << e.what() << std::endl;
    return 1;
  }

  return 0;
}
